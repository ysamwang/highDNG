cor
.calcTauScaled1 <- function(k, pa, ch) {
pa.2kminus2 <- sqrt(mean(pa^(2 * k - 2)))
ch.2 <- sqrt(mean(ch^2))
pa.2 <- sqrt(mean(pa^2))
abs( mean(pa^(k - 1) * ch)/ (pa.2kminus2 * ch.2) - mean(pa^k) / (sqrt(mean(pa^(2 * k - 2))) * pa.2 ) * mean(pa * ch) / (pa.2 * ch.2) )
}
bound <- sqrt(3)
n <- 50
Y <- runif(n, -bound, bound)
X <- .6 * Y + runif(n, -bound, bound)
.calcTauScaled <- function(k, pa, ch) {
abs(((n-1) / n) * cor(pa^(k - 1) , ch) - mean(pa^k) / (((n-1) / n) * sqrt(var(pa^(k-1)) * var(pa) )) * cor(pa, ch))
}
.calcTauScaled1 <- function(k, pa, ch) {
pa.2kminus2 <- sqrt(mean(pa^(2 * k - 2)))
ch.2 <- sqrt(mean(ch^2))
pa.2 <- sqrt(mean(pa^2))
abs( mean(pa^(k - 1) * ch)/ (pa.2kminus2 * ch.2) - mean(pa^k) / (sqrt(mean(pa^(2 * k - 2))) * pa.2 ) * mean(pa * ch) / (pa.2 * ch.2) )
}
.calcTauScaled1(4, X, Y)
.calcTauScaled(4, X, Y)
cor(X, Y)
mean(X * Y)
mean(X * Y) / sqrt(mean(X^2) * mean(Y^2))
######################################################
#
# Compare C++ inner function vs fastLM function
#
######################################################
library(doParallel)
source("functions/rDAG.R")
source("functions/findGraphMulti.R")
source("functions/findGraphSingle.R")
source("functions/findGraphSingleFast.R")
source("functions/findGraphSingleScaled.R")
ncores <- 6
cl <- makeCluster(ncores)
registerDoParallel(cl)
p <- 20
n <- 100
sim.size <- 10
val.list <- c(T, F)
timing.rec <- cor.rec <- matrix(0, nrow = sim.size * length(val.list), ncol = 4)
count <- 1
for(varParam in val.list){
for(i in 1:sim.size){
cat(i)
cat("\n")
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = varParam)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
time2 <- system.time(output2 <- findGraphSingle(scale(out_dag$Y, center = F), maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
time3 <- system.time(output3 <- findGraphSingleScaled(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
time4 <- system.time(output4 <- findGraphSingleScaled(scale(out_dag$Y, center = F), maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
cor.rec[count, ] <- c(cor(output1$topOrder, out_dag$topOrder, method = "kendall"),
cor(output2$topOrder, out_dag$topOrder, method = "kendall"),
cor(output3$topOrder, out_dag$topOrder, method = "kendall"),
cor(output4$topOrder, out_dag$topOrder, method = "kendall"))
timing.rec[count, ] <- c(time1[3], time2[3],time3[3], time4[3])
### update table
count <- count + 1
}
}
tab <- cbind(rep(val.list, each = sim.size), cor.rec)
par(mfrow = c(1,2))
boxplot(tab[1:sim.size,2:5])
abline(h = 0)
boxplot(tab[(sim.size + 1):(sim.size * 2),2:5])
abline(h = 0)
timing.rec
stopCluster(cl)
######################################################
#
# Compare C++ inner function vs fastLM function
#
######################################################
library(doParallel)
source("functions/rDAG.R")
source("functions/findGraphMulti.R")
source("functions/findGraphSingle.R")
source("functions/findGraphSingleFast.R")
source("functions/findGraphSingleScaled.R")
ncores <- 6
cl <- makeCluster(ncores)
registerDoParallel(cl)
p <- 50
n <- 100
sim.size <- 10
val.list <- c(T, F)
timing.rec <- cor.rec <- matrix(0, nrow = sim.size * length(val.list), ncol = 4)
count <- 1
for(varParam in val.list){
for(i in 1:sim.size){
cat(i)
cat("\n")
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = varParam)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
time2 <- system.time(output2 <- findGraphSingle(scale(out_dag$Y, center = F), maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
time3 <- system.time(output3 <- findGraphSingleScaled(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
time4 <- system.time(output4 <- findGraphSingleScaled(scale(out_dag$Y, center = F), maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
cor.rec[count, ] <- c(cor(output1$topOrder, out_dag$topOrder, method = "kendall"),
cor(output2$topOrder, out_dag$topOrder, method = "kendall"),
cor(output3$topOrder, out_dag$topOrder, method = "kendall"),
cor(output4$topOrder, out_dag$topOrder, method = "kendall"))
timing.rec[count, ] <- c(time1[3], time2[3],time3[3], time4[3])
### update table
count <- count + 1
}
}
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
time3 <- system.time(output3 <- findGraphSingleScaled(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =T))
#############################################################################################################
#     Recover graph from observational non-Gaussian Data
#
#     We calculate tau_i <- min_C max_j tau_{i-> j.C}
#
#
# Y:              n x p matrix of observations with sample in row, variable in column
# maxInDegree:    Assumed largest in-degree
# degree:         The assumed degree of non-Gaussianity
# pruningCut:     Fixed cut-off value
# fun:            The aggregation function. Should be max
# subsets:        Whether to condition on all subsets of variables, or just test sets of largest size
# B:              True DAG structure if available
# cutOffScaling:  Scaling factor for how to set the cutOff
# verbose:        Print progress updates
#
#############################################################################################################
findGraphSingleScaled <- function(Y, maxInDegree = 3, degree = 3, pruningCut = NULL, fun = max,
B = NULL, cutOffScaling = .5, verbose = T) {
# check to make sure the function used to aggregate is either sum or max
if(!identical(fun, sum) && !identical(fun, max)){
print("Unrecognized function")
stop()
}
n <- dim(Y)[1]
.calcTauScaled <- function(k, pa, ch) {
pa.2kminus2 <- sqrt(mean(pa^(2 * k - 2)))
ch.2 <- sqrt(mean(ch^2))
pa.2 <- sqrt(mean(pa^2))
abs( mean(pa^(k - 1) * ch)/ (pa.2kminus2 * ch.2) - mean(pa^k) / (sqrt(mean(pa^(2 * k - 2))) * pa.2 ) * mean(pa * ch) / (pa.2 * ch.2) )
}
# helper to go through all sets
.getTauSingle <- function(i, j, degree, conditionSet, maxInDegree){
####### Set up #######
j <- setdiff(j, i)
p <- dim(Y)[2]
pruneStat <- rep(1e5, p)
tauStat <- 3
if(length(conditionSet) == 0){
### Should only be run when ordered = NULL
pruneStat[j] <- sapply(j, function(j){.calcTauScaled(degree, Y[, i], Y[, j])})
tauStat <- fun( pruneStat[j] )
return(list(pruneStat = pruneStat, tauStat = tauStat))
} else {
### If considering all subsets smaller than maxInDegree, then start at subset of
### largest.set.size is the largest set we should consider
size.of.set <- min(maxInDegree, length(conditionSet))
### Ensure that each conditioning sub-set includes the last node
### So that we are not re-testing conditioning sets
if(length(conditionSet) == 1){
conditionSubSet <- matrix(conditionSet, nrow = 1, ncol = 1)
} else {
conditionSubSet <- t(combn(conditionSet, size.of.set))
}
### calculate regression for each possible conditioning set
for(z in 1:dim(conditionSubSet)[1]){
res <- RcppArmadillo::fastLm(X = Y[, conditionSubSet[z, ]], y = Y[, i])$residual
# Update the tau for all currently unordered nodes
tau.C <- sapply(j, function(j){.calcTauScaled(k = degree, pa = res, ch = Y[, j])})
pruneStat[j] <- pmin(pruneStat[j], tau.C)
# update tauStat
tauStat <- min(tauStat, fun( tau.C ))
# Update the tau for ancestors but possibly not parents
conditionNodesToTest <- setdiff(conditionSet, conditionSubSet[z, ])
pruneStat[conditionNodesToTest] <- pmin(pruneStat[conditionNodesToTest],
sapply(conditionNodesToTest, function(j){.calcTauScaled(k = degree, pa = res,
ch = Y[, j])}))
}
# only return the test stat values which were ever touched
return(list(pruneStat = pruneStat, tauStat = tauStat))
}
}
################### End getTau Function ###################
if(is.null(pruningCut)){
cutOff <- 0
} else {
cutOff <- pruningCut
}
# topological ordering of nodes
ordered <- c()
p <- dim(Y)[2]
# set of nodes which have not yet been ordered
unordered <- c(1:p)
### Record of lowest tau value achieved so far
pruneStats <- matrix(1e5, nrow =  p, ncol = p)
diag(pruneStats) <- 0
while(length(unordered) > 1){
# Testing for Root
output <- foreach(i = unordered) %dopar%{
if(!is.null(B)){
condSet <- intersect(which(B[i, ] != 0), ordered)
} else {
condSet <- union(intersect(ordered, which(pruneStats[i, ] > cutOff)), ordered[length(ordered)])
}
### Test to see if i has any parents left in unordered
.getTauSingle(i, j = unordered, degree = degree, conditionSet = condSet,
maxInDegree = maxInDegree)
}
output_pruneStats <- round(t(sapply(output, function(x){x$pruneStat})),7)
output_tauStats <- round(sapply(output, function(x){x$tauStat}), 7)
root <- unordered[which.min(output_tauStats)]
pa <- union(intersect(ordered, which(pruneStats[root, ] > cutOff)), ordered[length(ordered)])
pruneStats[unordered, ] <- pmin(pruneStats[unordered, ], output_pruneStats)
# Update cutoff if pruningCut is not set to a fixed value
if(is.null(pruningCut)){
cutOff <- max(cutOff, min(output_tauStats) * cutOffScaling)
}
# Print
if(verbose){
cat("====")
cat(length(ordered))
cat("====\n")
cat("Roots: "); cat(root); cat("; Parents: "); cat(pa)
cat("\n")
cat("\n")
names(output_tauStats) <- unordered
print(round(output_tauStats, 3))
cat("Cutoff: "); cat(round(cutOff,3)); cat("\n\n")
}
# Update topological ordering
ordered <- c(ordered, root)
unordered <- setdiff(unordered, root)
}
return(list(topOrder = c(ordered, unordered), prune = pruneStats))
}
library(doParallel)
source("functions/rDAG.R")
source("functions/findGraphMulti.R")
source("functions/findGraphSingle.R")
source("functions/findGraphSingleFast.R")
source("functions/findGraphSingleScaled.R")
ncores <- 6
cl <- makeCluster(ncores)
registerDoParallel(cl)
n <- 1000
p <- 20
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
output3 <- findGraphSingleScaled(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =T)
p <- 20
n <- 10000
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
output3 <- findGraphSingleScaled(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =T)
out_dag$Y
output3 <- findGraphSingleScaled(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =T)
output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =T)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 0,
fun = max, degree = 4, verbose =T))
# Generate DAG with set maxInDegree
# p - number of nodes
# n - number of samples
# maxInDeg - maximum number of samples
# dist - distribution of errors
rDAG_degree <- function(p, n, maxInDeg = 4, dist = "gamma", varParam = T){
B <- matrix(0, nrow = p, ncol = p)
for(i in 3:p){
if(maxInDeg > 1){
# randomly select number of parents between 1 and maxInDeg
numParents <- sample.int(min(maxInDeg - 1, i - 2), size = 1)
# ensure that i-1 is parent so that there is a unique ordering
parents <- c(sample(1:(i-2), size = numParents))
# set edge weights
B[i, parents] <- 1/4 # runif(numParents + 1, .2, 1) * ((runif(numParents + 1) < .5) * 2 - 1)
}
B[i, i-1] <- runif(1, .5, .8)
}
B[2, 1] <- runif(1, .5, .8)
if(dist == "gamma"){
avec <- rep(.2, p)
bvec <- rep(sqrt(.2), p)
errs <- mapply(function(a,b,n){rgamma(n, a, b) - a/b}, avec, bvec, n)
} else if (dist == "unif"){
if(varParam){
errs <- sapply(runif(p, sqrt(3), 4), function(x){runif(n, -x, x)})
} else {
errs <- matrix(rnorm(n * p, -sqrt(3), sqrt(3)), nrow = n, ncol = p)
}
} else if(dist == "gauss"){
errs <- matrix(rnorm(n * p), nrow = n, ncol = p)
}
topOrder <- p:1 #sample(p)
B <- B[topOrder, topOrder]
Y <- solve(diag(rep(1,p)) - B, t(errs))
return(list(B = B, Y = t(Y),
topOrder = order(topOrder)))
}
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 0,
fun = max, degree = 4, verbose =T))
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
cov(out_dag$Y)
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
cov(out_dag$Y)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 0,
fun = max, degree = 4, verbose =T))
cl <- makeCluster(ncores)
registerDoParallel(cl)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 0,
fun = max, degree = 4, verbose =T))
# Generate DAG with set maxInDegree
# p - number of nodes
# n - number of samples
# maxInDeg - maximum number of samples
# dist - distribution of errors
rDAG_degree <- function(p, n, maxInDeg = 4, dist = "gamma", varParam = T){
B <- matrix(0, nrow = p, ncol = p)
for(i in 3:p){
if(maxInDeg > 1){
# randomly select number of parents between 1 and maxInDeg
numParents <- sample.int(min(maxInDeg - 1, i - 2), size = 1)
# ensure that i-1 is parent so that there is a unique ordering
parents <- c(sample(1:(i-2), size = numParents))
# set edge weights
B[i, parents] <- 1/4 # runif(numParents + 1, .2, 1) * ((runif(numParents + 1) < .5) * 2 - 1)
}
B[i, i-1] <- runif(1, .5, .8)
}
B[2, 1] <- runif(1, .5, .8)
if(dist == "gamma"){
avec <- rep(.2, p)
bvec <- rep(sqrt(.2), p)
errs <- mapply(function(a,b,n){rgamma(n, a, b) - a/b}, avec, bvec, n)
} else if (dist == "unif"){
if(varParam){
errs <- sapply(runif(p, 1, 2), function(x){runif(n, -x, x)})
} else {
errs <- matrix(rnorm(n * p, -sqrt(3), sqrt(3)), nrow = n, ncol = p)
}
} else if(dist == "gauss"){
errs <- matrix(rnorm(n * p), nrow = n, ncol = p)
}
topOrder <- p:1 #sample(p)
B <- B[topOrder, topOrder]
Y <- solve(diag(rep(1,p)) - B, t(errs))
return(list(B = B, Y = t(Y),
topOrder = order(topOrder)))
}
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
cov(out_dag$Y)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 0,
fun = max, degree = 4, verbose =T))
# Generate DAG with set maxInDegree
# p - number of nodes
# n - number of samples
# maxInDeg - maximum number of samples
# dist - distribution of errors
rDAG_degree <- function(p, n, maxInDeg = 4, dist = "gamma", varParam = T){
B <- matrix(0, nrow = p, ncol = p)
for(i in 3:p){
if(maxInDeg > 1){
# randomly select number of parents between 1 and maxInDeg
numParents <- sample.int(min(maxInDeg - 1, i - 2), size = 1)
# ensure that i-1 is parent so that there is a unique ordering
parents <- c(sample(1:(i-2), size = numParents))
# set edge weights
B[i, parents] <- 1/4 # runif(numParents + 1, .2, 1) * ((runif(numParents + 1) < .5) * 2 - 1)
}
B[i, i-1] <- runif(1, .4, .7)
}
B[2, 1] <- runif(1, .4, .7)
if(dist == "gamma"){
avec <- rep(.2, p)
bvec <- rep(sqrt(.2), p)
errs <- mapply(function(a,b,n){rgamma(n, a, b) - a/b}, avec, bvec, n)
} else if (dist == "unif"){
if(varParam){
errs <- sapply(runif(p, 1, 2), function(x){runif(n, -x, x)})
} else {
errs <- matrix(rnorm(n * p, -sqrt(3), sqrt(3)), nrow = n, ncol = p)
}
} else if(dist == "gauss"){
errs <- matrix(rnorm(n * p), nrow = n, ncol = p)
}
topOrder <- p:1 #sample(p)
B <- B[topOrder, topOrder]
Y <- solve(diag(rep(1,p)) - B, t(errs))
return(list(B = B, Y = t(Y),
topOrder = order(topOrder)))
}
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 0,
fun = max, degree = 4, verbose =T))
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 0,
fun = max, degree = 4, verbose =T))
stopCluster(cl)
stopCluster(cl)
registerDoParallel(cl)
cl <- makeCluster(ncores)
registerDoParallel(cl)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 0,
fun = max, degree = 4, verbose =T))
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 1/4,
fun = max, degree = 4, verbose =T))
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 1/4,
fun = max, degree = 4, verbose =T))
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 1/4,
fun = max, degree = 4, verbose =T))
registerDoParallel(cl)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 1/4,
fun = max, degree = 4, verbose =T))
stopCluster(cl)
registerDoParallel(cl)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 1/4,
fun = max, degree = 4, verbose =T))
registerDoParallel(cl)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 1/4,
fun = max, degree = 4, verbose =T))
cl <- makeCluster(ncores)
registerDoParallel(cl)
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 1/4,
fun = max, degree = 4, verbose =T))
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = 5,
fun = max, degree = 4, verbose =T))
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = .05,
fun = max, degree = 4, verbose =T))
time3 <- system.time(output3 <- findGraphSingleScaled(out_dag$Y, maxInDegree = 3, cutOffScaling = .05,
fun = max, degree = 4, verbose =T))
?ricf
library(BCD)
?ricf
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
source("functions/rDAG.R")
source("functions/findGraphMulti.R")
source("functions/findGraphSingle.R")
source("functions/findGraphSingleFast.R")
source("functions/findGraphSingleScaled.R")
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
p <- 20
n <- 1000
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
out_dag$Y
ricf_out <- ricf(B = out_dag$B > 0, Omega = diag(rep(1, p)), Y = t(out_dag$Y))
ricf_out
ricf_out$B
out_dag$B > 0
out_dag$B
ricf_out$B
ricf_out
ricf_out$O
######################################################
#
# Compare C++ inner function vs fastLM function
#
######################################################
library(doParallel)
source("functions/rDAG.R")
source("functions/findGraphMulti.R")
source("functions/findGraphSingle.R")
source("functions/findGraphSingleFast.R")
source("functions/findGraphSingleScaled.R")
ncores <- 6
cl <- makeCluster(ncores)
registerDoParallel(cl)
p <- 20
n <- 1000
sim.size <- 10
val.list <- c(T, F)
timing.rec <- cor.rec <- matrix(0, nrow = sim.size * length(val.list), ncol = 4)
count <- 1
for(varParam in val.list){
for(i in 1:sim.size){
cat(i)
cat("\n")
out_dag <- rDAG_degree(p = p, n = n, maxInDeg = 3, dist = "unif", varParam = F)
cov(out_dag$Y)
ricf_out <- ricf(B = out_dag$B > 0, Omega = diag(rep(1, p)), Y = t(out_dag$Y))
time1 <- system.time(output1 <- findGraphSingle(out_dag$Y, maxInDegree = 3, cutOffScaling = .05,
fun = max, degree = 4, verbose =T))
time2 <- system.time(output2 <- findGraphSingle(scale(out_dag$Y, center = F), maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
time3 <- system.time(output3 <- findGraphSingleScaled(out_dag$Y, maxInDegree = 3, cutOffScaling = .05,
fun = max, degree = 4, verbose =T))
time4 <- system.time(output4 <- findGraphSingleScaled(scale(out_dag$Y, center = F), maxInDegree = 3, cutOffScaling = .5,
fun = max, degree = 4, verbose =F))
cor.rec[count, ] <- c(cor(output1$topOrder, out_dag$topOrder, method = "kendall"),
cor(output2$topOrder, out_dag$topOrder, method = "kendall"),
cor(output3$topOrder, out_dag$topOrder, method = "kendall"),
cor(output4$topOrder, out_dag$topOrder, method = "kendall"))
timing.rec[count, ] <- c(time1[3], time2[3],time3[3], time4[3])
### update table
count <- count + 1
}
}
tab <- cbind(rep(val.list, each = sim.size), cor.rec)
par(mfrow = c(1,2))
boxplot(tab[1:sim.size,2:5])
abline(h = 0)
boxplot(tab[(sim.size + 1):(sim.size * 2),2:5])
abline(h = 0)
timing.rec
stopCluster(cl)
